import * as chromadb_default_embed from 'chromadb-default-embed';
import * as _google_generative_ai from '@google/generative-ai';
import * as ollama from 'ollama';
import * as openai from 'openai';
import * as _xenova_transformers from '@xenova/transformers';

type EmbeddingFunctionSpace = "cosine" | "l2" | "ip";
interface IEmbeddingFunction {
    generate(texts: string[]): Promise<number[][]>;
    name?: string;
    defaultSpace?(): EmbeddingFunctionSpace;
    supportedSpaces?(): EmbeddingFunctionSpace[];
    buildFromConfig?(config: Record<string, any>): IEmbeddingFunction;
    getConfig?(): Record<string, any>;
    validateConfigUpdate?(oldConfig: Record<string, any>, newConfig: Record<string, any>): void;
    validateConfig?(config: Record<string, any>): void;
}

type AuthHeaders = {
    [header: string]: string;
};
type TokenHeaderType = "AUTHORIZATION" | "X_CHROMA_TOKEN";
type AuthOptions = {
    provider: ClientAuthProvider | string | undefined;
    credentials?: any | undefined;
    tokenHeaderType?: TokenHeaderType | undefined;
};
interface ClientAuthProvider {
    /**
     * Abstract method for authenticating a client.
     */
    authenticate(): AuthHeaders;
}

/**
 * chroma-frontend
 *
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
interface ConfigurationParameters {
    apiKey?: string | ((name: string) => string | null);
    username?: string;
    password?: string;
    authorization?: string | ((name: string, scopes?: string[]) => string | null);
    basePath?: string;
}
declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | ((name: string) => string | null);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2, openIdConnect or http security
     * @param name security name
     * @param scopes oauth2 scopes
     * @memberof Configuration
     */
    authorization?: string | ((name: string, scopes?: string[]) => string | null);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    constructor(param?: ConfigurationParameters);
}

/**
 * chroma-frontend
 *
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
declare const defaultFetch: typeof fetch;

/**
 *
 * @export
 * @type FetchAPI
 */
type FetchAPI = typeof defaultFetch;
/**
 *
 * @export
 * @class BaseAPI
 */
declare class BaseAPI {
    protected basePath: string;
    protected fetch: FetchAPI;
    protected configuration?: Configuration;
    constructor(configuration?: Configuration, basePath?: string, fetch?: FetchAPI);
}

/**
 * chroma-frontend
 *
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
declare namespace Api {
    interface AddCollectionRecordsPayload {
        documents?: (string | null)[] | null;
        embeddings?: number[][] | null;
        ids: string[];
        metadatas?: ({
            [name: string]: boolean | number | number | string;
        } | null)[] | null;
        uris?: (string | null)[] | null;
    }
    interface AddCollectionRecordsResponse {
    }
    interface ChecklistResponse {
        /**
         * @type {number}
         * @memberof ChecklistResponse
         * minimum: 0
         */
        max_batch_size: number;
    }
    interface Collection {
        configuration_json: Api.CollectionConfiguration;
        database: string;
        /**
         * @type {number | null}
         * @memberof Collection
         */
        dimension?: number | null;
        /**
         * @description <p>CollectionUuid is a wrapper around Uuid to provide a type for the collection id.</p>
         * @type {string}
         * @memberof Collection
         */
        id: string;
        /**
         * @type {number}
         * @memberof Collection
         */
        log_position: number;
        metadata?: {
            [name: string]: boolean | number | number | string;
        } | null;
        name: string;
        tenant: string;
        /**
         * @type {number}
         * @memberof Collection
         */
        version: number;
    }
    interface CollectionConfiguration {
        embedding_function?: Api.EmbeddingFunctionConfiguration | null;
        hnsw?: Api.HnswConfiguration | null;
        spann?: Api.SpannConfiguration | null;
    }
    interface CreateCollectionPayload {
        configuration?: Api.CollectionConfiguration | null;
        get_or_create?: boolean;
        metadata?: {
            [name: string]: boolean | number | number | string;
        } | null;
        name: string;
    }
    interface CreateDatabasePayload {
        name: string;
    }
    interface CreateDatabaseResponse {
    }
    interface CreateTenantPayload {
        name: string;
    }
    interface CreateTenantResponse {
    }
    interface Database {
        id: string;
        name: string;
        tenant: string;
    }
    interface DeleteCollectionRecordsPayload extends Api.RawWhereFields {
        ids?: string[] | null;
    }
    interface DeleteCollectionRecordsResponse {
    }
    interface DeleteDatabaseResponse {
    }
    type EmbeddingFunctionConfiguration = Api.EmbeddingFunctionConfiguration.ObjectValue | Api.EmbeddingFunctionConfiguration.AllofValue;
    /**
     * @export
     * @namespace EmbeddingFunctionConfiguration
     */
    namespace EmbeddingFunctionConfiguration {
        interface ObjectValue {
            type: Api.EmbeddingFunctionConfiguration.ObjectValue.TypeEnum;
        }
        /**
         * @export
         * @namespace ObjectValue
         */
        namespace ObjectValue {
            enum TypeEnum {
                Legacy = "legacy"
            }
        }
        interface AllofValue extends Api.EmbeddingFunctionNewConfiguration {
            type: Api.EmbeddingFunctionConfiguration.AllofValue.TypeEnum;
        }
        /**
         * @export
         * @namespace AllofValue
         */
        namespace AllofValue {
            enum TypeEnum {
                Known = "known"
            }
        }
    }
    interface EmbeddingFunctionNewConfiguration {
        config: unknown;
        name: string;
    }
    interface ErrorResponse {
        error: string;
        message: string;
    }
    interface ForkCollectionPayload {
        new_name: string;
    }
    interface GetRequestPayload extends Api.RawWhereFields {
        ids?: string[] | null;
        include?: Api.Include[];
        /**
         * @type {number | null}
         * @memberof GetRequestPayload
         * minimum: 0
         */
        limit?: number | null;
        /**
         * @type {number | null}
         * @memberof GetRequestPayload
         * minimum: 0
         */
        offset?: number | null;
    }
    interface GetResponse {
        documents?: (string | null)[] | null;
        embeddings?: number[][] | null;
        ids: string[];
        include: Api.Include[];
        metadatas?: ({
            [name: string]: boolean | number | number | string;
        } | null)[] | null;
        uris?: (string | null)[] | null;
    }
    interface GetTenantResponse {
        name: string;
    }
    interface GetUserIdentityResponse {
        databases: string[];
        tenant: string;
        user_id: string;
    }
    interface HeartbeatResponse {
        /**
         * @type {number}
         * @memberof HeartbeatResponse
         * minimum: 0
         */
        "nanosecond heartbeat": number;
    }
    interface HnswConfiguration {
        /**
         * @type {number | null}
         * @memberof HnswConfiguration
         * minimum: 0
         */
        ef_construction?: number | null;
        /**
         * @type {number | null}
         * @memberof HnswConfiguration
         * minimum: 0
         */
        ef_search?: number | null;
        /**
         * @type {number | null}
         * @memberof HnswConfiguration
         * minimum: 0
         */
        max_neighbors?: number | null;
        /**
         * @type {number | null}
         * @memberof HnswConfiguration
         */
        resize_factor?: number | null;
        space?: Api.HnswSpace;
        /**
         * @type {number | null}
         * @memberof HnswConfiguration
         * minimum: 0
         */
        sync_threshold?: number | null;
    }
    enum HnswSpace {
        L2 = "l2",
        Cosine = "cosine",
        Ip = "ip"
    }
    enum Include {
        Distances = "distances",
        Documents = "documents",
        Embeddings = "embeddings",
        Metadatas = "metadatas",
        Uris = "uris"
    }
    interface QueryRequestPayload extends Api.RawWhereFields {
        ids?: string[] | null;
        include?: Api.Include[];
        /**
         * @type {number | null}
         * @memberof QueryRequestPayload
         * minimum: 0
         */
        n_results?: number | null;
        query_embeddings: number[][];
    }
    interface QueryResponse {
        distances?: (number | null)[][] | null;
        documents?: (string | null)[][] | null;
        embeddings?: (number[] | null)[][] | null;
        ids: string[][];
        include: Api.Include[];
        metadatas?: ({
            [name: string]: boolean | number | number | string;
        } | null)[][] | null;
        uris?: (string | null)[][] | null;
    }
    interface RawWhereFields {
        where?: unknown;
        where_document?: unknown;
    }
    interface SpannConfiguration {
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        ef_construction?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        ef_search?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        max_neighbors?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        merge_threshold?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        reassign_neighbor_count?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        search_nprobe?: number | null;
        space?: Api.HnswSpace;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        split_threshold?: number | null;
        /**
         * @type {number | null}
         * @memberof SpannConfiguration
         * minimum: 0
         */
        write_nprobe?: number | null;
    }
    interface UpdateCollectionConfiguration {
        embedding_function?: Api.EmbeddingFunctionConfiguration | null;
        hnsw?: Api.UpdateHnswConfiguration | null;
        spann?: Api.SpannConfiguration | null;
    }
    interface UpdateCollectionPayload {
        new_configuration?: Api.UpdateCollectionConfiguration | null;
        new_metadata?: {
            [name: string]: boolean | number | number | string;
        } | null;
        new_name?: string | null;
    }
    interface UpdateCollectionRecordsPayload {
        documents?: (string | null)[] | null;
        embeddings?: (number[] | null)[] | null;
        ids: string[];
        metadatas?: ({
            [name: string]: boolean | number | number | string;
        } | null)[] | null;
        uris?: (string | null)[] | null;
    }
    interface UpdateCollectionRecordsResponse {
    }
    interface UpdateCollectionResponse {
    }
    interface UpdateHnswConfiguration {
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         * minimum: 0
         */
        batch_size?: number | null;
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         * minimum: 0
         */
        ef_search?: number | null;
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         * minimum: 0
         */
        max_neighbors?: number | null;
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         * minimum: 0
         */
        num_threads?: number | null;
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         */
        resize_factor?: number | null;
        /**
         * @type {number | null}
         * @memberof UpdateHnswConfiguration
         * minimum: 0
         */
        sync_threshold?: number | null;
    }
    interface UpsertCollectionRecordsPayload {
        documents?: (string | null)[] | null;
        embeddings?: number[][] | null;
        ids: string[];
        metadatas?: ({
            [name: string]: boolean | number | number | string;
        } | null)[] | null;
        uris?: (string | null)[] | null;
    }
    interface UpsertCollectionRecordsResponse {
    }
    interface Vec2 {
        configuration_json: Api.CollectionConfiguration;
        database: string;
        /**
         * @type {number | null}
         * @memberof Vec2
         */
        dimension?: number | null;
        /**
         * @description <p>CollectionUuid is a wrapper around Uuid to provide a type for the collection id.</p>
         * @type {string}
         * @memberof Vec2
         */
        id: string;
        /**
         * @type {number}
         * @memberof Vec2
         */
        log_position: number;
        metadata?: {
            [name: string]: boolean | number | number | string;
        } | null;
        name: string;
        tenant: string;
        /**
         * @type {number}
         * @memberof Vec2
         */
        version: number;
    }
}

/**
 * chroma-frontend
 *
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
declare class ApiApi extends BaseAPI {
    /**
     * @summary Adds records to a collection.
     * @param {string} tenant
     * @param {string} database
     * @param {string} collectionId
     * @param {Api.AddCollectionRecordsPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionAdd(tenant: string, database: string, collectionId: string, request: Api.AddCollectionRecordsPayload, options?: RequestInit): Promise<Api.AddCollectionRecordsResponse>;
    /**
     * @summary Retrieves the number of records in a collection.
     * @param {string} tenant <p>Tenant ID for the collection</p>
     * @param {string} database <p>Database containing this collection</p>
     * @param {string} collectionId <p>Collection ID whose records are counted</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionCount(tenant: string, database: string, collectionId: string, options?: RequestInit): Promise<number>;
    /**
     * @summary Deletes records in a collection. Can filter by IDs or metadata.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>Collection ID</p>
     * @param {Api.DeleteCollectionRecordsPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionDelete(tenant: string, database: string, collectionId: string, request: Api.DeleteCollectionRecordsPayload, options?: RequestInit): Promise<Api.DeleteCollectionRecordsResponse>;
    /**
     * @summary Retrieves records from a collection by ID or metadata filter.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name for the collection</p>
     * @param {string} collectionId <p>Collection ID to fetch records from</p>
     * @param {Api.GetRequestPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionGet(tenant: string, database: string, collectionId: string, request: Api.GetRequestPayload, options?: RequestInit): Promise<Api.GetResponse>;
    /**
     * @summary Query a collection in a variety of ways, including vector search, metadata filtering, and full-text search
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name containing the collection</p>
     * @param {string} collectionId <p>Collection ID to query</p>
     * @param {number} [limit] <p>Limit for pagination</p>
     * @param {number} [offset] <p>Offset for pagination</p>
     * @param {Api.QueryRequestPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionQuery(tenant: string, database: string, collectionId: string, limit: number | undefined, offset: number | undefined, request: Api.QueryRequestPayload, options?: RequestInit): Promise<Api.QueryResponse>;
    /**
     * @summary Updates records in a collection by ID.
     * @param {string} tenant
     * @param {string} database
     * @param {string} collectionId
     * @param {Api.UpdateCollectionRecordsPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionUpdate(tenant: string, database: string, collectionId: string, request: Api.UpdateCollectionRecordsPayload, options?: RequestInit): Promise<Api.UpdateCollectionRecordsResponse>;
    /**
     * @summary Upserts records in a collection (create if not exists, otherwise update).
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>Collection ID</p>
     * @param {Api.UpsertCollectionRecordsPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectionUpsert(tenant: string, database: string, collectionId: string, request: Api.UpsertCollectionRecordsPayload, options?: RequestInit): Promise<Api.UpsertCollectionRecordsResponse>;
    /**
     * @summary Retrieves the total number of collections in a given database.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name to count collections from</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    countCollections(tenant: string, database: string, options?: RequestInit): Promise<number>;
    /**
     * @summary Creates a new collection under the specified database.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name containing the new collection</p>
     * @param {Api.CreateCollectionPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(tenant: string, database: string, request: Api.CreateCollectionPayload, options?: RequestInit): Promise<Api.Collection>;
    /**
     * @summary Creates a new database for a given tenant.
     * @param {string} tenant <p>Tenant ID to associate with the new database</p>
     * @param {Api.CreateDatabasePayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDatabase(tenant: string, request: Api.CreateDatabasePayload, options?: RequestInit): Promise<Api.CreateDatabaseResponse>;
    /**
     * @summary Creates a new tenant.
     * @param {Api.CreateTenantPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant(request: Api.CreateTenantPayload, options?: RequestInit): Promise<Api.CreateTenantResponse>;
    /**
     * @summary Deletes a collection in a given database.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>UUID of the collection to delete</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(tenant: string, database: string, collectionId: string, options?: RequestInit): Promise<Api.UpdateCollectionResponse>;
    /**
     * @summary Deletes a specific database.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Name of the database to delete</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDatabase(tenant: string, database: string, options?: RequestInit): Promise<Api.DeleteDatabaseResponse>;
    /**
     * @summary Forks an existing collection.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>UUID of the collection to update</p>
     * @param {Api.ForkCollectionPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    forkCollection(tenant: string, database: string, collectionId: string, request: Api.ForkCollectionPayload, options?: RequestInit): Promise<Api.Collection>;
    /**
     * @summary Retrieves a collection by ID or name.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>UUID of the collection</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(tenant: string, database: string, collectionId: string, options?: RequestInit): Promise<Api.Collection>;
    /**
     * @summary Retrieves a specific database by name.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Name of the database to retrieve</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDatabase(tenant: string, database: string, options?: RequestInit): Promise<Api.Database>;
    /**
     * @summary Returns an existing tenant by name.
     * @param {string} tenantName <p>Tenant name or ID to retrieve</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant(tenantName: string, options?: RequestInit): Promise<Api.GetTenantResponse>;
    /**
     * @summary Retrieves the current user's identity, tenant, and databases.
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentity(options?: RequestInit): Promise<Api.GetUserIdentityResponse>;
    /**
     * @summary Health check endpoint that returns 200 if the server and executor are ready
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthcheck(options?: RequestInit): Promise<string>;
    /**
     * @summary Heartbeat endpoint that returns a nanosecond timestamp of the current time.
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(options?: RequestInit): Promise<Api.HeartbeatResponse>;
    /**
     * @summary Lists all collections in the specified database.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name to list collections from</p>
     * @param {number} [limit] <p>Limit for pagination</p>
     * @param {number} [offset] <p>Offset for pagination</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(tenant: string, database: string, limit: number | undefined, offset: number | undefined, options?: RequestInit): Promise<Api.Vec2[]>;
    /**
     * @summary Lists all databases for a given tenant.
     * @param {string} tenant <p>Tenant ID to list databases for</p>
     * @param {number} [limit] <p>Limit for pagination</p>
     * @param {number} [offset] <p>Offset for pagination</p>
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listDatabases(tenant: string, limit: number | undefined, offset: number | undefined, options?: RequestInit): Promise<Api.Vec2[]>;
    /**
     * @summary Pre-flight checks endpoint reporting basic readiness info.
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    preFlightChecks(options?: RequestInit): Promise<Api.ChecklistResponse>;
    /**
     * @summary Reset endpoint allowing authorized users to reset the database.
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(options?: RequestInit): Promise<boolean>;
    /**
     * @summary Updates an existing collection's name or metadata.
     * @param {string} tenant <p>Tenant ID</p>
     * @param {string} database <p>Database name</p>
     * @param {string} collectionId <p>UUID of the collection to update</p>
     * @param {Api.UpdateCollectionPayload} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(tenant: string, database: string, collectionId: string, request: Api.UpdateCollectionPayload, options?: RequestInit): Promise<Api.UpdateCollectionResponse>;
    /**
     * @summary Returns the version of the server.
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    version(options?: RequestInit): Promise<string>;
}

type HnswSpace = EmbeddingFunctionSpace;
interface HNSWConfiguration {
    space?: HnswSpace;
    ef_construction?: number;
    max_neighbors?: number;
    ef_search?: number;
    num_threads?: number;
    batch_size?: number;
    sync_threshold?: number;
    resize_factor?: number;
}
interface CreateHNSWConfiguration extends HNSWConfiguration {
}
interface UpdateHNSWConfiguration {
    ef_search?: number;
    num_threads?: number;
    batch_size?: number;
    sync_threshold?: number;
    resize_factor?: number;
}
interface SpannConfiguration {
    space?: EmbeddingFunctionSpace;
    search_nprobe?: number;
    write_nprobe?: number;
    ef_construction?: number;
    max_neighbors?: number;
    ef_search?: number;
    reassign_neighbor_count?: number;
    split_threshold?: number;
    merge_threshold?: number;
}
interface CreateSpannConfiguration extends SpannConfiguration {
}
interface UpdateSpannConfiguration {
    search_nprobe?: number;
    ef_search?: number;
}
interface CreateCollectionConfiguration {
    hnsw?: CreateHNSWConfiguration | null;
    spann?: CreateSpannConfiguration | null;
    embedding_function?: IEmbeddingFunction | null;
}
interface UpdateCollectionConfiguration {
    hnsw?: UpdateHNSWConfiguration | null;
    spann?: UpdateSpannConfiguration | null;
    embedding_function?: IEmbeddingFunction | null;
}

declare enum IncludeEnum {
    Documents = "documents",
    Embeddings = "embeddings",
    Metadatas = "metadatas",
    Distances = "distances",
    Uris = "uris"
}
type Embedding = number[];
type Embeddings = Embedding[];
type Metadata = Record<string, string | number | boolean>;
type Metadatas = Metadata[];
type Document = string;
type Documents = Document[];
type ID = string;
type IDs = ID[];
type PositiveInteger = number;
type LiteralValue = string | number | boolean;
type ListLiteralValue = LiteralValue[];
type LiteralNumber = number;
type LogicalOperator = "$and" | "$or";
type InclusionOperator = "$in" | "$nin";
type WhereOperator = "$gt" | "$gte" | "$lt" | "$lte" | "$ne" | "$eq";
type OperatorExpression = {
    [key in WhereOperator | InclusionOperator | LogicalOperator]?: LiteralValue | ListLiteralValue;
};
type BaseWhere = {
    [key: string]: LiteralValue | OperatorExpression;
};
type LogicalWhere = {
    [key in LogicalOperator]?: Where[];
};
type Where = BaseWhere | LogicalWhere;
type WhereDocumentOperator = "$contains" | "$not_contains" | LogicalOperator;
type WhereDocument = {
    [key in WhereDocumentOperator]?: LiteralValue | LiteralNumber | WhereDocument[];
};
type MultiGetResponse = {
    ids: IDs;
    embeddings: Embeddings | null;
    documents: (Document | null)[];
    metadatas: (Metadata | null)[];
    included: IncludeEnum[];
};
type GetResponse = MultiGetResponse;
type SingleQueryResponse = {
    ids: IDs;
    embeddings: Embeddings | null;
    documents: (Document | null)[];
    metadatas: (Metadata | null)[];
    distances: number[] | null;
    included: IncludeEnum[];
};
type MultiQueryResponse = {
    ids: IDs[];
    embeddings: Embeddings[] | null;
    documents: (Document | null)[][];
    metadatas: (Metadata | null)[][];
    distances: number[][] | null;
    included: IncludeEnum[];
};
type QueryResponse = SingleQueryResponse | MultiQueryResponse;
interface CollectionParams {
    name: string;
    id: string;
    metadata: CollectionMetadata | undefined;
    embeddingFunction: IEmbeddingFunction;
    configuration: Api.CollectionConfiguration | undefined;
}
type CollectionMetadata = Record<string, boolean | number | string>;
type ConfigOptions = {
    options?: RequestInit;
};
type BaseGetParams = {
    ids?: ID | IDs;
    where?: Where;
    limit?: PositiveInteger;
    offset?: PositiveInteger;
    include?: IncludeEnum[];
    whereDocument?: WhereDocument;
};
type SingleGetParams = BaseGetParams & {
    ids: ID;
};
type MultiGetParams = BaseGetParams & {
    ids?: IDs;
};
type GetParams = SingleGetParams | MultiGetParams;
type ListCollectionsParams = {
    limit?: PositiveInteger;
    offset?: PositiveInteger;
};
type ChromaClientParams = {
    path?: string;
    fetchOptions?: RequestInit;
    auth?: AuthOptions;
    tenant?: string;
    database?: string;
};
type CreateCollectionParams = {
    name: string;
    metadata?: CollectionMetadata;
    embeddingFunction?: IEmbeddingFunction;
    configuration?: CreateCollectionConfiguration;
};
type GetOrCreateCollectionParams = CreateCollectionParams;
type GetCollectionParams = {
    name: string;
    embeddingFunction?: IEmbeddingFunction;
};
type DeleteCollectionParams = {
    name: string;
};
type BaseRecordOperationParams = {
    ids: ID | IDs;
    embeddings?: Embedding | Embeddings;
    metadatas?: Metadata | Metadatas;
    documents?: Document | Documents;
};
type SingleRecordOperationParams = BaseRecordOperationParams & {
    ids: ID;
    embeddings?: Embedding;
    metadatas?: Metadata;
    documents?: Document;
};
type SingleEmbeddingRecordOperationParams = SingleRecordOperationParams & {
    embeddings: Embedding;
};
type SingleContentRecordOperationParams = SingleRecordOperationParams & {
    documents: Document;
};
type SingleAddRecordOperationParams = SingleEmbeddingRecordOperationParams | SingleContentRecordOperationParams;
type MultiRecordOperationParams = BaseRecordOperationParams & {
    ids: IDs;
    embeddings?: Embeddings;
    metadatas?: Metadatas;
    documents?: Documents;
};
type MultiEmbeddingRecordOperationParams = MultiRecordOperationParams & {
    embeddings: Embeddings;
};
type MultiContentRecordOperationParams = MultiRecordOperationParams & {
    documents: Documents;
};
type MultiAddRecordsOperationParams = MultiEmbeddingRecordOperationParams | MultiContentRecordOperationParams;
type AddRecordsParams = SingleAddRecordOperationParams | MultiAddRecordsOperationParams;
type UpsertRecordsParams = AddRecordsParams;
type UpdateRecordsParams = MultiRecordOperationParams | SingleRecordOperationParams;
type ModifyCollectionParams = {
    name?: string;
    metadata?: CollectionMetadata;
};
type ForkCollectionParams = {
    newName: string;
};
type BaseQueryParams = {
    ids?: ID | IDs;
    nResults?: PositiveInteger;
    where?: Where;
    queryTexts?: string | string[];
    queryEmbeddings?: Embedding | Embeddings;
    whereDocument?: WhereDocument;
    include?: IncludeEnum[];
};
type SingleTextQueryParams = BaseQueryParams & {
    queryTexts: string;
    queryEmbeddings?: never;
};
type SingleEmbeddingQueryParams = BaseQueryParams & {
    queryTexts?: never;
    queryEmbeddings: Embedding;
};
type MultiTextQueryParams = BaseQueryParams & {
    queryTexts: string[];
    queryEmbeddings?: never;
};
type MultiEmbeddingQueryParams = BaseQueryParams & {
    queryTexts?: never;
    queryEmbeddings: Embeddings;
};
type QueryRecordsParams = SingleTextQueryParams | SingleEmbeddingQueryParams | MultiTextQueryParams | MultiEmbeddingQueryParams;
type PeekParams = {
    limit?: PositiveInteger;
};
type DeleteParams = {
    ids?: ID | IDs;
    where?: Where;
    whereDocument?: WhereDocument;
};

declare class Collection {
    name: string;
    id: string;
    metadata: CollectionMetadata | undefined;
    /**
     * @ignore
     */
    private client;
    /**
     * @ignore
     */
    embeddingFunction: IEmbeddingFunction;
    configuration: Api.CollectionConfiguration | undefined;
    /**
     * @ignore
     */
    constructor(name: string, id: string, client: ChromaClient, embeddingFunction: IEmbeddingFunction, metadata?: CollectionMetadata, configuration?: Api.CollectionConfiguration);
    /**
     * Add items to the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - IDs of the items to add.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
     * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
     * @returns {Promise<AddResponse>} - The response from the API. True if successful.
     *
     * @example
     * ```typescript
     * const response = await collection.add({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["document1", "document2"]
     * });
     * ```
     */
    add(params: AddRecordsParams): Promise<void>;
    /**
     * Upsert items to the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - IDs of the items to add.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
     * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
     * @returns {Promise<void>}
     *
     * @example
     * ```typescript
     * const response = await collection.upsert({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["document1", "document2"],
     * });
     * ```
     */
    upsert(params: UpsertRecordsParams): Promise<void>;
    /**
     * Count the number of items in the collection
     * @returns {Promise<number>} - The number of items in the collection.
     *
     * @example
     * ```typescript
     * const count = await collection.count();
     * ```
     */
    count(): Promise<number>;
    /**
     * Get items from the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - Optional IDs of the items to get.
     * @param {Where} [params.where] - Optional where clause to filter items by.
     * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
     * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
     * @param {IncludeEnum[]} [params.include] - Optional list of items to include in the response.
     * @param {WhereDocument} [params.whereDocument] - Optional where clause to filter items by.
     * @returns {Promise<GetResponse>} - The response from the server.
     *
     * @example
     * ```typescript
     * const response = await collection.get({
     *   ids: ["id1", "id2"],
     *   where: { "key": "value" },
     *   limit: 10,
     *   offset: 0,
     *   include: ["embeddings", "metadatas", "documents"],
     *   whereDocument: { "$contains": "value" },
     * });
     * ```
     */
    get({ ids, where, limit, offset, include, whereDocument, }?: BaseGetParams): Promise<GetResponse>;
    /**
     * Update items in the collection
     * @param {Object} params - The parameters for the query.
     * @param {ID | IDs} [params.ids] - IDs of the items to add.
     * @param {Embedding | Embeddings} [params.embeddings] - Optional embeddings of the items to add.
     * @param {Metadata | Metadatas} [params.metadatas] - Optional metadata of the items to add.
     * @param {Document | Documents} [params.documents] - Optional documents of the items to add.
     * @returns {Promise<void>}
     *
     * @example
     * ```typescript
     * const response = await collection.update({
     *   ids: ["id1", "id2"],
     *   embeddings: [[1, 2, 3], [4, 5, 6]],
     *   metadatas: [{ "key": "value" }, { "key": "value" }],
     *   documents: ["document1", "document2"],
     * });
     * ```
     */
    update(params: UpdateRecordsParams): Promise<void>;
    /**
     * Performs a query on the collection using the specified parameters.
     *
     * @param {Object} params - The parameters for the query.
     * @param {Embedding | Embeddings} [params.queryEmbeddings] - Optional query embeddings to use for the search.
     * @param {PositiveInteger} [params.nResults] - Optional number of results to return (default is 10).
     * @param {Where} [params.where] - Optional query condition to filter results based on metadata values.
     * @param {string | string[]} [params.queryTexts] - Optional query text(s) to search for in the collection.
     * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter results based on document content.
     * @param {IncludeEnum[]} [params.include] - Optional array of fields to include in the result, such as "metadata" and "document".
     * @param {IDs} [params.ids] - Optional IDs to filter on before querying.
     *
     * @returns {Promise<QueryResponse>} A promise that resolves to the query results.
     * @throws {Error} If there is an issue executing the query.
     * @example
     * // Query the collection using embeddings
     * const results = await collection.query({
     *   queryEmbeddings: [[0.1, 0.2, ...], ...],
     *   nResults: 10,
     *   where: {"name": {"$eq": "John Doe"}},
     *   include: ["metadata", "document"]
     * });
     * @example
     * ```js
     * // Query the collection using query text
     * const results = await collection.query({
     *   queryTexts: "some text",
     *   nResults: 10,
     *   where: {"name": {"$eq": "John Doe"}},
     *   include: ["metadata", "document"]
     * });
     * ```
     *
     */
    query({ nResults, where, whereDocument, include, queryTexts, queryEmbeddings, ids, }: QueryRecordsParams): Promise<MultiQueryResponse>;
    /**
     * Modify the collection name or metadata
     * @param {Object} params - The parameters for the query.
     * @param {string} [params.name] - Optional new name for the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional new metadata for the collection.
     * @returns {Promise<void>} - The response from the API.
     *
     * @example
     * ```typescript
     * const response = await client.updateCollection({
     *   name: "new name",
     *   metadata: { "key": "value" },
     * });
     * ```
     */
    modify({ name, metadata, configuration, }: {
        name?: string;
        metadata?: CollectionMetadata;
        configuration?: UpdateCollectionConfiguration;
    }): Promise<CollectionParams>;
    /**
     * Peek inside the collection
     * @param {Object} params - The parameters for the query.
     * @param {PositiveInteger} [params.limit] - Optional number of results to return (default is 10).
     * @returns {Promise<GetResponse>} A promise that resolves to the query results.
     * @throws {Error} If there is an issue executing the query.
     *
     * @example
     * ```typescript
     * const results = await collection.peek({
     *   limit: 10
     * });
     * ```
     */
    peek({ limit }?: PeekParams): Promise<MultiGetResponse>;
    /**
     * Deletes items from the collection.
     * @param {Object} params - The parameters for deleting items from the collection.
     * @param {ID | IDs} [params.ids] - Optional ID or array of IDs of items to delete.
     * @param {Where} [params.where] - Optional query condition to filter items to delete based on metadata values.
     * @param {WhereDocument} [params.whereDocument] - Optional query condition to filter items to delete based on document content.
     * @returns {Promise<string[]>} A promise that resolves to the IDs of the deleted items.
     * @throws {Error} If there is an issue deleting items from the collection.
     *
     * @example
     * ```typescript
     * const results = await collection.delete({
     *   ids: "some_id",
     *   where: {"name": {"$eq": "John Doe"}},
     *   whereDocument: {"$contains":"search_string"}
     * });
     * ```
     */
    delete({ ids, where, whereDocument, }?: DeleteParams): Promise<void>;
    /**
     * Forks the collection into a new collection with a new name and configuration.
     *
     * @param {Object} params - The parameters for forking the collection.
     * @param {string} params.newName - The name for the new forked collection.
     *
     * @returns {Promise<Collection>} A promise that resolves to the new forked Collection object.
     * @throws {Error} If there is an issue forking the collection.
     *
     * @example
     * ```typescript
     * const newCollection = await collection.fork({
     *   newName: "my_forked_collection",
     * });
     * ```
     */
    fork({ newName }: ForkCollectionParams): Promise<Collection>;
}

declare class ChromaClient {
    /**
     * @ignore
     */
    api: ApiApi & ConfigOptions;
    /**
     * @ignore
     */
    tenant: string;
    /**
     * @ignore
     */
    database: string;
    /**
     * @ignore
     */
    private _adminClient;
    /**
     * @ignore
     */
    private authProvider;
    /**
     * @ignore
     */
    private _initPromise;
    /**
     * Creates a new ChromaClient instance.
     * @param {Object} params - The parameters for creating a new client
     * @param {string} [params.path] - The base path for the Chroma API.
     * @returns {ChromaClient} A new ChromaClient instance.
     *
     * @example
     * ```typescript
     * const client = new ChromaClient({
     *   path: "http://localhost:8000"
     * });
     * ```
     */
    constructor({ path, fetchOptions, auth, tenant, database, }?: ChromaClientParams);
    /** @ignore */
    init(): Promise<void>;
    /**
     * Tries to set the tenant and database for the client.
     *
     * @returns {Promise<void>} A promise that resolves when the tenant/database is resolved.
     * @throws {Error} If there is an issue resolving the tenant and database.
     *
     */
    getUserIdentity(): Promise<void>;
    /**
     * Resets the state of the object by making an API call to the reset endpoint.
     *
     * @returns {Promise<boolean>} A promise that resolves when the reset operation is complete.
     * @throws {ChromaConnectionError} If the client is unable to connect to the server.
     * @throws {ChromaServerError} If the server experienced an error while the state.
     *
     * @example
     * ```typescript
     * await client.reset();
     * ```
     */
    reset(): Promise<boolean>;
    /**
     * Returns the version of the Chroma API.
     * @returns {Promise<string>} A promise that resolves to the version of the Chroma API.
     * @throws {ChromaConnectionError} If the client is unable to connect to the server.
     *
     * @example
     * ```typescript
     * const version = await client.version();
     * ```
     */
    version(): Promise<string>;
    /**
     * Returns a heartbeat from the Chroma API.
     * @returns {Promise<number>} A promise that resolves to the heartbeat from the Chroma API.
     * @throws {ChromaConnectionError} If the client is unable to connect to the server.
     *
     * @example
     * ```typescript
     * const heartbeat = await client.heartbeat();
     * ```
     */
    heartbeat(): Promise<number>;
    /**
     * Creates a new collection with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new collection.
     * @param {string} params.name - The name of the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     *
     * @returns {Promise<Collection>} A promise that resolves to the created collection.
     * @throws {ChromaConnectionError} If the client is unable to connect to the server.
     * @throws {ChromaServerError} If there is an issue creating the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.createCollection({
     *   name: "my_collection",
     *   metadata: {
     *     "description": "My first collection"
     *   }
     * });
     * ```
     */
    createCollection({ name, metadata, embeddingFunction, configuration, }: CreateCollectionParams): Promise<Collection>;
    /**
     * Gets or creates a collection with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new collection.
     * @param {string} params.name - The name of the collection.
     * @param {CollectionMetadata} [params.metadata] - Optional metadata associated with the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     *
     * @returns {Promise<Collection>} A promise that resolves to the got or created collection.
     * @throws {Error} If there is an issue getting or creating the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.getOrCreateCollection({
     *   name: "my_collection",
     *   metadata: {
     *     "description": "My first collection"
     *   }
     * });
     * ```
     */
    getOrCreateCollection({ name, metadata, embeddingFunction, configuration, }: GetOrCreateCollectionParams): Promise<Collection>;
    /**
     * Get all collection names.
     *
     * @returns {Promise<string[]>} A promise that resolves to a list of collection names.
     * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
     * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
     * @throws {Error} If there is an issue listing the collections.
     *
     * @example
     * ```typescript
     * const collections = await client.listCollections({
     *     limit: 10,
     *     offset: 0,
     * });
     * ```
     */
    listCollections({ limit, offset }?: ListCollectionsParams): Promise<string[]>;
    /**
     * List collection names, IDs, and metadata.
     *
     * @param {PositiveInteger} [params.limit] - Optional limit on the number of items to get.
     * @param {PositiveInteger} [params.offset] - Optional offset on the items to get.
     * @throws {Error} If there is an issue listing the collections.
     * @returns {Promise<{ name: string, id: string, metadata?: CollectionMetadata }[]>} A promise that resolves to a list of collection names, IDs, and metadata.
     *
     * @example
     * ```typescript
     * const collections = await client.listCollectionsAndMetadata({
     *    limit: 10,
     *    offset: 0,
     * });
     */
    listCollectionsAndMetadata({ limit, offset, }?: ListCollectionsParams): Promise<{
        name: string;
        id: string;
        metadata?: CollectionMetadata;
    }[]>;
    /**
     * Counts all collections.
     *
     * @returns {Promise<number>} A promise that resolves to the number of collections.
     * @throws {Error} If there is an issue counting the collections.
     *
     * @example
     * ```typescript
     * const collections = await client.countCollections();
     * ```
     */
    countCollections(): Promise<number>;
    /**
     * Gets a collection with the specified name.
     * @param {Object} params - The parameters for getting a collection.
     * @param {string} params.name - The name of the collection.
     * @param {IEmbeddingFunction} [params.embeddingFunction] - Optional custom embedding function for the collection.
     * @returns {Promise<Collection>} A promise that resolves to the collection.
     * @throws {Error} If there is an issue getting the collection.
     *
     * @example
     * ```typescript
     * const collection = await client.getCollection({
     *   name: "my_collection"
     * });
     * ```
     */
    getCollection({ name, embeddingFunction, }: GetCollectionParams): Promise<Collection>;
    /**
     * Deletes a collection with the specified name.
     * @param {Object} params - The parameters for deleting a collection.
     * @param {string} params.name - The name of the collection.
     * @returns {Promise<void>} A promise that resolves when the collection is deleted.
     * @throws {Error} If there is an issue deleting the collection.
     *
     * @example
     * ```typescript
     * await client.deleteCollection({
     *  name: "my_collection"
     * });
     * ```
     */
    deleteCollection({ name }: DeleteCollectionParams): Promise<void>;
}

interface Tenant {
    name: string;
}
interface Database {
    id: string;
    tenant: string;
    name: string;
}
declare class AdminClient {
    /**
     * @ignore
     */
    private api;
    private authProvider;
    tenant: string;
    database: string;
    /**
     * Creates a new AdminClient instance.
     * @param {Object} params - The parameters for creating a new client
     * @param {string} [params.path] - The base path for the Chroma API.
     * @returns {AdminClient} A new AdminClient instance.
     *
     * @example
     * ```typescript
     * const client = new AdminClient({
     *   path: "http://localhost:8000"
     * });
     * ```
     */
    constructor({ path, fetchOptions, auth, tenant, database, }?: {
        path?: string;
        fetchOptions?: RequestInit;
        auth?: AuthOptions;
        tenant?: string;
        database?: string;
    });
    /**
     * Sets the tenant and database for the client.
     *
     * @param {Object} params - The parameters for setting tenant and database.
     * @param {string} params.tenant - The name of the tenant.
     * @param {string} params.database - The name of the database.
     *
     * @returns {Promise<void>} A promise that returns nothing
     * @throws {Error} Any issues
     *
     * @example
     * ```typescript
     * await adminClient.setTenant({
     *   tenant: "my_tenant",
     *   database: "my_database",
     * });
     * ```
     */
    setTenant({ tenant, database, }: {
        tenant: string;
        database?: string;
    }): Promise<void>;
    /**
     * Sets the database for the client.
     *
     * @param {Object} params - The parameters for setting the database.
     * @param {string} params.database - The name of the database.
     *
     * @returns {Promise<void>} A promise that returns nothing
     * @throws {Error} Any issues
     *
     * @example
     * ```typescript
     * await adminClient.setDatabase({
     *   database: "my_database",
     * });
     * ```
     */
    setDatabase({ database, }: {
        database?: string;
    }): Promise<void>;
    /**
     * Creates a new tenant with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new tenant.
     * @param {string} params.name - The name of the tenant.
     *
     * @returns {Promise<Tenant>} A promise that resolves to the created tenant.
     * @throws {Error} If there is an issue creating the tenant.
     *
     * @example
     * ```typescript
     * await adminClient.createTenant({
     *   name: "my_tenant",
     * });
     * ```
     */
    createTenant({ name }: {
        name: string;
    }): Promise<Tenant>;
    /**
     * Gets a tenant with the specified properties.
     *
     * @param {Object} params - The parameters for getting a tenant.
     * @param {string} params.name - The name of the tenant.
     *
     * @returns {Promise<Tenant>} A promise that resolves to the tenant.
     * @throws {Error} If there is an issue getting the tenant.
     *
     * @example
     * ```typescript
     * await adminClient.getTenant({
     *   name: "my_tenant",
     * });
     * ```
     */
    getTenant({ name }: {
        name: string;
    }): Promise<Tenant>;
    /**
     * Creates a new database with the specified properties.
     *
     * @param {Object} params - The parameters for creating a new database.
     * @param {string} params.name - The name of the database.
     * @param {string} params.tenantName - The name of the tenant.
     *
     * @returns {Promise<Database>} A promise that resolves to the created database.
     * @throws {Error} If there is an issue creating the database.
     *
     * @example
     * ```typescript
     * await adminClient.createDatabase({
     *   name: "my_database",
     *   tenantName: "my_tenant",
     * });
     * ```
     */
    createDatabase({ name, tenantName, }: {
        name: string;
        tenantName: string;
    }): Promise<{
        name: string;
    }>;
    /**
     * Gets a database with the specified properties.
     *
     * @param {Object} params - The parameters for getting a database.
     * @param {string} params.name - The name of the database.
     * @param {string} params.tenantName - The name of the tenant.
     *
     * @returns {Promise<Database>} A promise that resolves to the database.
     * @throws {Error} If there is an issue getting the database.
     *
     * @example
     * ```typescript
     * await adminClient.getDatabase({
     *   name: "my_database",
     *   tenantName: "my_tenant",
     * });
     * ```
     */
    getDatabase({ name, tenantName, }: {
        name: string;
        tenantName: string;
    }): Promise<Database>;
    /**
     * Deletes a database.
     *
     * @param {Object} params - The parameters for deleting a database.
     * @param {string} params.name - The name of the database.
     * @param {string} params.tenantName - The name of the tenant.
     *
     * @returns {Promise<void>} A promise that returns nothing.
     * @throws {Error} If there is an issue deleting the database.
     */
    deleteDatabase({ name, tenantName, }: {
        name: string;
        tenantName: string;
    }): Promise<void>;
    /**
     * Lists database for a specific tenant.
     *
     * @param {Object} params - The parameters for listing databases.
     * @param {number} [params.limit] - The maximum number of databases to return.
     * @param {number} [params.offset] - The number of databases to skip.
     *
     * @returns {Promise<Database[]>} A promise that resolves to a list of databases.
     * @throws {Error} If there is an issue listing the databases.
     */
    listDatabases({ limit, offset, tenantName, }: {
        limit?: number;
        offset?: number;
        tenantName: string;
    }): Promise<Database[]>;
}

interface CloudClientParams {
    apiKey?: string;
    database?: string;
    tenant?: string;
    cloudHost?: string;
    cloudPort?: string;
}
declare class CloudClient extends ChromaClient {
    constructor({ apiKey, database, tenant, cloudHost, cloudPort, }: CloudClientParams);
}

interface StoredConfig$a {
    model_name: string;
    api_key_env_var: string;
}
declare class CohereEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private cohereAiApi?;
    private model;
    private isImage;
    private apiKey;
    private apiKeyEnvVar;
    constructor({ cohere_api_key, model, cohere_api_key_env_var, 
    /**
     * If true, the input texts passed to `generate` are expected to be
     * base64 encoded PNG data URIs.
     */
    isImage, }: {
        cohere_api_key?: string;
        model?: string;
        cohere_api_key_env_var: string;
        /**
         * If true, the input texts passed to `generate` are expected to be
         * base64 encoded PNG data URIs.
         */
        isImage?: boolean;
    });
    private initCohereClient;
    generate(texts: string[]): Promise<number[][]>;
    buildFromConfig(config: StoredConfig$a): CohereEmbeddingFunction;
    getConfig(): StoredConfig$a;
    validateConfigUpdate(oldConfig: StoredConfig$a, newConfig: StoredConfig$a): void;
    validateConfig(config: StoredConfig$a): void;
    supportedSpaces(): EmbeddingFunctionSpace[];
    defaultSpace(): EmbeddingFunctionSpace;
}

interface StoredConfig$9 {
    model: string;
    revision: string;
    quantized: boolean;
}
declare class DefaultEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private pipelinePromise?;
    private transformersApi;
    private model;
    private revision;
    private quantized;
    private progress_callback;
    /**
     * DefaultEmbeddingFunction constructor.
     * @param options The configuration options.
     * @param options.model The model to use to calculate embeddings. Defaults to 'Xenova/all-MiniLM-L6-v2', which is an ONNX port of `sentence-transformers/all-MiniLM-L6-v2`.
     * @param options.revision The specific model version to use (can be a branch, tag name, or commit id). Defaults to 'main'.
     * @param options.quantized Whether to load the 8-bit quantized version of the model. Defaults to `false`.
     * @param options.progress_callback If specified, this function will be called during model construction, to provide the user with progress updates.
     */
    constructor({ model, revision, quantized, progress_callback, }?: {
        model?: string;
        revision?: string;
        quantized?: boolean;
        progress_callback?: Function | null;
    });
    generate(texts: string[]): Promise<number[][]>;
    getConfig(): StoredConfig$9;
    buildFromConfig(config: StoredConfig$9): DefaultEmbeddingFunction;
    validateConfigUpdate(oldConfig: StoredConfig$9, newConfig: StoredConfig$9): void;
    validateConfig(config: StoredConfig$9): void;
    private loadClient;
    /** @ignore */
    static import(): Promise<{
        pipeline: typeof chromadb_default_embed;
    }>;
}

interface StoredConfig$8 {
    api_key_env_var: string;
    model_name: string;
    task_type: string;
}
declare class GoogleGenerativeAiEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private api_key;
    private api_key_env_var;
    private model;
    private googleGenAiApi?;
    private taskType;
    constructor({ googleApiKey, model, taskType, apiKeyEnvVar, }: {
        googleApiKey?: string;
        model?: string;
        taskType?: string;
        apiKeyEnvVar: string;
    });
    private loadClient;
    generate(texts: string[]): Promise<any>;
    /** @ignore */
    static import(): Promise<{
        googleGenAi: typeof _google_generative_ai;
    }>;
    buildFromConfig(config: StoredConfig$8): GoogleGenerativeAiEmbeddingFunction;
    getConfig(): StoredConfig$8;
    validateConfigUpdate(oldConfig: Record<string, any>, newConfig: Record<string, any>): void;
    validateConfig(config: Record<string, any>): void;
}

type StoredConfig$7 = {
    url: string;
    api_key_env_var?: string;
};
declare class HuggingFaceEmbeddingServerFunction implements IEmbeddingFunction {
    name: string;
    private url;
    private api_key_env_var?;
    private headers?;
    constructor({ api_key, url, api_key_env_var, }: {
        url: string;
        api_key?: string;
        api_key_env_var?: string;
    });
    generate(texts: string[]): Promise<any>;
    buildFromConfig(config: StoredConfig$7): HuggingFaceEmbeddingServerFunction;
    getConfig(): StoredConfig$7;
    validateConfigUpdate(oldConfig: Record<string, any>, newConfig: Record<string, any>): void;
    validateConfig(config: Record<string, any>): void;
}

type StoredConfig$6 = {
    api_key_env_var: string;
    model_name: string;
    task?: string;
    late_chunking?: boolean;
    truncate?: boolean;
    dimensions?: number;
    embedding_type?: string;
    normalized?: boolean;
};
declare class JinaEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private api_key_env_var;
    private model_name;
    private api_url;
    private headers;
    private task;
    private late_chunking;
    private truncate;
    private dimensions;
    private embedding_type;
    private normalized;
    constructor({ jinaai_api_key, model_name, api_key_env_var, task, late_chunking, truncate, dimensions, embedding_type, normalized, }: {
        jinaai_api_key?: string;
        model_name?: string;
        api_key_env_var: string;
        task?: string;
        late_chunking?: boolean;
        truncate?: boolean;
        dimensions?: number;
        embedding_type?: string;
        normalized?: boolean;
    });
    generate(texts: string[]): Promise<any[]>;
    buildFromConfig(config: StoredConfig$6): JinaEmbeddingFunction;
    getConfig(): StoredConfig$6;
    validateConfig(config: StoredConfig$6): void;
}

type StoredConfig$5 = {
    url: string;
    model_name: string;
};
declare class OllamaEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private readonly url;
    private readonly model;
    private ollamaClient?;
    constructor({ url, model, }?: {
        url?: string;
        model?: string;
    });
    private initClient;
    /** @ignore */
    static import(): Promise<{
        ollama: typeof ollama;
    }>;
    generate(texts: string[]): Promise<any>;
    buildFromConfig(config: StoredConfig$5): OllamaEmbeddingFunction;
    getConfig(): StoredConfig$5;
    validateConfig(config: StoredConfig$5): void;
}

type StoredConfig$4 = {
    api_key_env_var: string;
    model_name: string;
    organization_id: string;
    dimensions: number;
};
declare class OpenAIEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private api_key;
    private org_id;
    private model;
    private openaiApi?;
    private dimensions?;
    constructor({ openai_api_key, openai_model, openai_organization_id, openai_embedding_dimensions, openai_api_key_env_var, }: {
        openai_api_key?: string;
        openai_model?: string;
        openai_organization_id?: string;
        openai_embedding_dimensions?: number;
        openai_api_key_env_var?: string;
    });
    private loadClient;
    generate(texts: string[]): Promise<number[][]>;
    /** @ignore */
    static import(): Promise<{
        openai: typeof openai;
        version: string;
    }>;
    buildFromConfig(config: StoredConfig$4): OpenAIEmbeddingFunction;
    getConfig(): StoredConfig$4;
    validateConfigUpdate(oldConfig: StoredConfig$4, newConfig: StoredConfig$4): void;
    validateConfig(config: StoredConfig$4): void;
}

type StoredConfig$3 = {
    model: string;
    revision: string;
    quantized: boolean;
};
declare class TransformersEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private pipelinePromise?;
    private transformersApi;
    private model;
    private revision;
    private quantized;
    private progress_callback;
    /**
     * TransformersEmbeddingFunction constructor.
     * @param options The configuration options.
     * @param options.model The model to use to calculate embeddings. Defaults to 'Xenova/all-MiniLM-L6-v2', which is an ONNX port of `sentence-transformers/all-MiniLM-L6-v2`.
     * @param options.revision The specific model version to use (can be a branch, tag name, or commit id). Defaults to 'main'.
     * @param options.quantized Whether to load the 8-bit quantized version of the model. Defaults to `false`.
     * @param options.progress_callback If specified, this function will be called during model construction, to provide the user with progress updates.
     */
    constructor({ model, revision, quantized, progress_callback, }?: {
        model?: string;
        revision?: string;
        quantized?: boolean;
        progress_callback?: Function | null;
    });
    generate(texts: string[]): Promise<number[][]>;
    private loadClient;
    /** @ignore */
    static import(): Promise<{
        pipeline: typeof _xenova_transformers;
    }>;
    buildFromConfig(config: StoredConfig$3): TransformersEmbeddingFunction;
    getConfig(): StoredConfig$3;
    validateConfigUpdate(oldConfig: StoredConfig$3, newConfig: StoredConfig$3): void;
    validateConfig(config: StoredConfig$3): void;
}

type StoredConfig$2 = {
    api_key_env_var: string;
    model_name: string;
};
declare class VoyageAIEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private voyageAiApi?;
    private model;
    private apiKey;
    private apiKeyEnvVar;
    constructor({ api_key, model, api_key_env_var, }: {
        api_key?: string;
        model: string;
        api_key_env_var: string;
    });
    private initClient;
    generate(texts: string[]): Promise<number[][]>;
    buildFromConfig(config: StoredConfig$2): VoyageAIEmbeddingFunction;
    getConfig(): StoredConfig$2;
    validateConfigUpdate(oldConfig: StoredConfig$2, newConfig: StoredConfig$2): void;
    validateConfig(config: StoredConfig$2): void;
}

type StoredConfig$1 = {
    account_id: string;
    model_name: string;
    api_key_env_var: string;
    gateway_id?: string;
};
declare class CloudflareWorkersAIEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private account_id;
    private model_name;
    private api_key_env_var;
    private gateway_id?;
    private api_url;
    private headers;
    constructor({ cloudflare_api_key, model_name, account_id, api_key_env_var, gateway_id, }: {
        cloudflare_api_key?: string;
        model_name: string;
        account_id: string;
        api_key_env_var: string;
        gateway_id?: string;
    });
    generate(texts: string[]): Promise<any>;
    buildFromConfig(config: StoredConfig$1): CloudflareWorkersAIEmbeddingFunction;
    getConfig(): StoredConfig$1;
    validateConfig(config: StoredConfig$1): void;
}

type StoredConfig = {
    model_name: string;
    api_key_env_var: string;
};
declare class TogetherAIEmbeddingFunction implements IEmbeddingFunction {
    name: string;
    private model_name;
    private api_key_env_var;
    private headers;
    constructor({ together_ai_api_key, model_name, api_key_env_var, }: {
        together_ai_api_key?: string;
        model_name: string;
        api_key_env_var: string;
    });
    generate(texts: string[]): Promise<number[][]>;
    buildFromConfig(config: StoredConfig): IEmbeddingFunction;
    getConfig(): StoredConfig;
    validateConfig(config: StoredConfig): void;
}

interface Schema {
    $schema: string;
    title?: string;
    description?: string;
    version?: string;
    type: string;
    properties: Record<string, any>;
    required?: string[];
    additionalProperties?: boolean;
    [key: string]: any;
}
declare const schemaMap: {
    amazon_bedrock: Schema;
    base_schema: Schema;
    chroma_langchain: Schema;
    cohere: Schema;
    default: Schema;
    google_generative_ai: Schema;
    google_palm: Schema;
    google_vertex: Schema;
    huggingface: Schema;
    huggingface_server: Schema;
    instructor: Schema;
    jina: Schema;
    ollama: Schema;
    onnx_mini_lm_l6_v2: Schema;
    open_clip: Schema;
    openai: Schema;
    roboflow: Schema;
    sentence_transformer: Schema;
    text2vec: Schema;
    transformers: Schema;
    voyageai: Schema;
    cloudflare_workers_ai: Schema;
    together_ai: Schema;
};
/**
 * Load a JSON schema.
 *
 * @param schemaName Name of the schema file (without .json extension)
 * @returns The loaded schema as an object
 * @throws Error if the schema is not available
 */
declare function loadSchema(schemaName: keyof typeof schemaMap): Schema;
/**
 * Validate a configuration against a schema.
 *
 * @param config Configuration to validate
 * @param schemaName Name of the schema file (without .json extension)
 * @throws Error if the configuration does not match the schema
 */
declare function validateConfigSchema(config: Record<string, any>, schemaName: keyof typeof schemaMap): void;
/**
 * Get the version of a schema.
 *
 * @param schemaName Name of the schema file (without .json extension)
 * @returns The schema version as a string
 * @throws Error if the schema file does not exist or is not valid JSON
 */
declare function getSchemaVersion(schemaName: keyof typeof schemaMap): string;
/**
 * Get a list of all available schemas.
 *
 * @returns A list of schema names (without .json extension)
 */
declare function getAvailableSchemas(): (keyof typeof schemaMap)[];
/**
 * Get information about all available schemas.
 *
 * @returns A dictionary mapping schema names to information about the schema
 */
declare function getSchemaInfo(): Record<string, {
    version: string;
    title: string;
    description: string;
}>;

/**
 * This is a generic Chroma error.
 */
declare class ChromaError extends Error {
    readonly cause?: unknown;
    constructor(name: string, message: string, cause?: unknown);
}
/**
 * Indicates that there was a problem with the connection to the Chroma server (e.g. the server is down or the client is not connected to the internet)
 */
declare class ChromaConnectionError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
/** Indicates that the server encountered an error while handling the request. */
declare class ChromaServerError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
/** Indicate that there was an issue with the request that the client made. */
declare class ChromaClientError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
/** The request lacked valid authentication. */
declare class ChromaUnauthorizedError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
/** The user does not have permission to access the requested resource. */
declare class ChromaForbiddenError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class ChromaNotFoundError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class ChromaValueError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class InvalidCollectionError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class InvalidArgumentError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class ChromaUniqueError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare class ChromaQuotaExceededError extends Error {
    readonly cause?: unknown;
    name: string;
    constructor(message: string, cause?: unknown);
}
declare function createErrorByType(type: string, message: string): InvalidCollectionError | InvalidArgumentError | undefined;

export { type AddRecordsParams, AdminClient, ChromaClient, ChromaClientError, type ChromaClientParams, ChromaConnectionError, ChromaError, ChromaForbiddenError, ChromaNotFoundError, ChromaQuotaExceededError, ChromaServerError, ChromaUnauthorizedError, ChromaUniqueError, ChromaValueError, CloudClient, CloudflareWorkersAIEmbeddingFunction, CohereEmbeddingFunction, Collection, type CollectionMetadata, type CollectionParams, type CreateCollectionParams, DefaultEmbeddingFunction, type DeleteCollectionParams, type DeleteParams, type Document, type Documents, type Embedding, type Embeddings, type GetCollectionParams, type GetOrCreateCollectionParams, type GetParams, type GetResponse, GoogleGenerativeAiEmbeddingFunction, HuggingFaceEmbeddingServerFunction, type ID, type IDs, type IEmbeddingFunction, IncludeEnum, InvalidArgumentError, InvalidCollectionError, JinaEmbeddingFunction, type ListCollectionsParams, type Metadata, type Metadatas, type ModifyCollectionParams, OllamaEmbeddingFunction, OpenAIEmbeddingFunction, type PeekParams, type QueryRecordsParams, type QueryResponse, TogetherAIEmbeddingFunction, TransformersEmbeddingFunction, type UpdateRecordsParams, type UpsertRecordsParams, VoyageAIEmbeddingFunction, type Where, type WhereDocument, createErrorByType, getAvailableSchemas, getSchemaInfo, getSchemaVersion, loadSchema, validateConfigSchema };
